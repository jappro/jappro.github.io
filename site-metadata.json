// =========================
// THEME TOGGLE
// =========================
const themeToggle = document.getElementById(â€˜themeToggleâ€™);
const htmlElement = document.documentElement;

// Check for saved theme preference or default to â€˜darkâ€™
const currentTheme = localStorage.getItem(â€˜themeâ€™) || â€˜darkâ€™;
htmlElement.setAttribute(â€˜data-themeâ€™, currentTheme);

themeToggle.addEventListener(â€˜clickâ€™, () => {
const theme = htmlElement.getAttribute(â€˜data-themeâ€™);
const newTheme = theme === â€˜darkâ€™ ? â€˜lightâ€™ : â€˜darkâ€™;

htmlElement.setAttribute(â€˜data-themeâ€™, newTheme);
localStorage.setItem(â€˜themeâ€™, newTheme);

// Add transition animation
document.body.style.transition = â€˜background-color 0.3s ease, color 0.3s easeâ€™;
});

// =========================
// MOBILE NAVIGATION
// =========================
const navToggle = document.getElementById(â€˜navToggleâ€™);
const nav = document.getElementById(â€˜navâ€™);

navToggle.addEventListener(â€˜clickâ€™, () => {
const expanded = navToggle.getAttribute(â€˜aria-expandedâ€™) === â€˜trueâ€™ || false;
navToggle.setAttribute(â€˜aria-expandedâ€™, !expanded);
nav.classList.toggle(â€˜openâ€™);
navToggle.classList.toggle(â€˜openâ€™);
});

// Close mobile nav on link click
document.querySelectorAll(â€™.main-nav aâ€™).forEach(link => {
link.addEventListener(â€˜clickâ€™, () => {
if (nav.classList.contains(â€˜openâ€™)) {
nav.classList.remove(â€˜openâ€™);
navToggle.classList.remove(â€˜openâ€™);
navToggle.setAttribute(â€˜aria-expandedâ€™, â€˜falseâ€™);
}
});
});

// Close mobile nav when clicking outside
document.addEventListener(â€˜clickâ€™, (e) => {
if (nav.classList.contains(â€˜openâ€™) &&
!nav.contains(e.target) &&
!navToggle.contains(e.target)) {
nav.classList.remove(â€˜openâ€™);
navToggle.classList.remove(â€˜openâ€™);
navToggle.setAttribute(â€˜aria-expandedâ€™, â€˜falseâ€™);
}
});

// =========================
// SKILLS CAROUSEL
// =========================
const carousel = document.querySelector(â€™.skills-carouselâ€™);
const prevBtn = document.querySelector(â€™.carousel-prevâ€™);
const nextBtn = document.querySelector(â€™.carousel-nextâ€™);
const indicators = document.querySelector(â€™.carousel-indicatorsâ€™);
const skillCards = document.querySelectorAll(â€™.skill-cardâ€™);

// Create indicators
skillCards.forEach((_, index) => {
const indicator = document.createElement(â€˜divâ€™);
indicator.classList.add(â€˜carousel-indicatorâ€™);
if (index === 0) indicator.classList.add(â€˜activeâ€™);
indicator.addEventListener(â€˜clickâ€™, () => scrollToCard(index));
indicators.appendChild(indicator);
});

const allIndicators = document.querySelectorAll(â€™.carousel-indicatorâ€™);

// Scroll to specific card
function scrollToCard(index) {
const card = skillCards[index];
const scrollLeft = card.offsetLeft - (carousel.offsetWidth / 2) + (card.offsetWidth / 2);
carousel.scrollTo({ left: scrollLeft, behavior: â€˜smoothâ€™ });
updateActiveIndicator(index);
}

// Update active indicator
function updateActiveIndicator(index) {
allIndicators.forEach((ind, i) => {
ind.classList.toggle(â€˜activeâ€™, i === index);
});
}

// Get current visible card index
function getCurrentCardIndex() {
const scrollLeft = carousel.scrollLeft;
const cardWidth = skillCards[0].offsetWidth + 24; // card width + gap
return Math.round(scrollLeft / cardWidth);
}

// Previous button
prevBtn.addEventListener(â€˜clickâ€™, () => {
const currentIndex = getCurrentCardIndex();
const newIndex = Math.max(0, currentIndex - 1);
scrollToCard(newIndex);
});

// Next button
nextBtn.addEventListener(â€˜clickâ€™, () => {
const currentIndex = getCurrentCardIndex();
const newIndex = Math.min(skillCards.length - 1, currentIndex + 1);
scrollToCard(newIndex);
});

// Update indicator on scroll
carousel.addEventListener(â€˜scrollâ€™, () => {
const currentIndex = getCurrentCardIndex();
updateActiveIndicator(currentIndex);
});

// Touch/swipe support for carousel
let startX = 0;
let scrollLeftStart = 0;

carousel.addEventListener(â€˜touchstartâ€™, (e) => {
startX = e.touches[0].pageX;
scrollLeftStart = carousel.scrollLeft;
});

carousel.addEventListener(â€˜touchmoveâ€™, (e) => {
const x = e.touches[0].pageX;
const walk = (startX - x) * 2;
carousel.scrollLeft = scrollLeftStart + walk;
});

// Auto-rotate carousel (optional - uncomment to enable)
/*
let autoRotateInterval;

function startAutoRotate() {
autoRotateInterval = setInterval(() => {
const currentIndex = getCurrentCardIndex();
const newIndex = (currentIndex + 1) % skillCards.length;
scrollToCard(newIndex);
}, 5000);
}

function stopAutoRotate() {
clearInterval(autoRotateInterval);
}

// Start auto-rotate
startAutoRotate();

// Pause on hover
carousel.addEventListener(â€˜mouseenterâ€™, stopAutoRotate);
carousel.addEventListener(â€˜mouseleaveâ€™, startAutoRotate);

// Pause on touch
carousel.addEventListener(â€˜touchstartâ€™, stopAutoRotate);
*/

// =========================
// CONTACT FORM HANDLING
// =========================
const contactForm = document.getElementById(â€˜contactFormâ€™);
const formStatus = document.getElementById(â€˜formStatusâ€™);

contactForm.addEventListener(â€˜submitâ€™, async (e) => {
e.preventDefault();

const formData = new FormData(contactForm);
const name = formData.get(â€˜nameâ€™);
const email = formData.get(â€˜emailâ€™);
const message = formData.get(â€˜messageâ€™);

// Create mailto link
const subject = encodeURIComponent(`Portfolio Contact from ${name}`);
const body = encodeURIComponent(
`Name: ${name}\nEmail: ${email}\n\nMessage:\n${message}`
);
const mailtoLink = `mailto:camzyxworld@gmail.com?subject=${subject}&body=${body}`;

// Show success message
formStatus.textContent = â€˜Opening your email clientâ€¦â€™;
formStatus.className = â€˜form-status successâ€™;

// Open mailto link
setTimeout(() => {
window.location.href = mailtoLink;

```
// Reset form after a delay
setTimeout(() => {
  contactForm.reset();
  formStatus.textContent = 'Email client opened! If it didn\'t open automatically, please email me directly at camzyxworld@gmail.com';
  
  // Hide status after 5 seconds
  setTimeout(() => {
    formStatus.style.display = 'none';
  }, 5000);
}, 1000);
```

}, 500);
});

// Alternative: FormSubmit.co integration (uncomment if you want a backend service)
/*
contactForm.addEventListener(â€˜submitâ€™, async (e) => {
e.preventDefault();

const formData = new FormData(contactForm);

try {
formStatus.textContent = â€˜Sending messageâ€¦â€™;
formStatus.className = â€˜form-statusâ€™;
formStatus.style.display = â€˜blockâ€™;

```
const response = await fetch('https://formsubmit.co/ajax/camzyxworld@gmail.com', {
  method: 'POST',
  body: formData
});

if (response.ok) {
  formStatus.textContent = 'Message sent successfully! I\'ll get back to you soon.';
  formStatus.className = 'form-status success';
  contactForm.reset();
  
  // Hide status after 5 seconds
  setTimeout(() => {
    formStatus.style.display = 'none';
  }, 5000);
} else {
  throw new Error('Failed to send message');
}
```

} catch (error) {
formStatus.textContent = â€˜Failed to send message. Please try emailing me directly at camzyxworld@gmail.comâ€™;
formStatus.className = â€˜form-status errorâ€™;
}
});
*/

// =========================
// SMOOTH SCROLL FOR ANCHOR LINKS
// =========================
document.querySelectorAll(â€˜a[href^=â€#â€]â€™).forEach(anchor => {
anchor.addEventListener(â€˜clickâ€™, function (e) {
const href = this.getAttribute(â€˜hrefâ€™);

```
// Don't prevent default for empty hash or just "#"
if (href === '#' || href === '') return;

e.preventDefault();
const target = document.querySelector(href);

if (target) {
  const headerOffset = 80;
  const elementPosition = target.getBoundingClientRect().top;
  const offsetPosition = elementPosition + window.pageYOffset - headerOffset;

  window.scrollTo({
    top: offsetPosition,
    behavior: 'smooth'
  });
}
```

});
});

// =========================
// SCROLL ANIMATIONS
// =========================
const observerOptions = {
threshold: 0.1,
rootMargin: â€˜0px 0px -50px 0pxâ€™
};

const observer = new IntersectionObserver((entries) => {
entries.forEach(entry => {
if (entry.isIntersecting) {
entry.target.style.animation = â€˜fadeInUp 0.8s ease bothâ€™;
observer.unobserve(entry.target);
}
});
}, observerOptions);

// Observe elements for animation
document.querySelectorAll(â€™.glass-card, .experience-item, .stat-itemâ€™).forEach(el => {
observer.observe(el);
});

// =========================
// HEADER SCROLL EFFECT
// =========================
let lastScroll = 0;
const header = document.querySelector(â€™.site-headerâ€™);

window.addEventListener(â€˜scrollâ€™, () => {
const currentScroll = window.pageYOffset;

if (currentScroll > 100) {
header.style.boxShadow = â€˜var(â€“shadow-md)â€™;
} else {
header.style.boxShadow = â€˜noneâ€™;
}

lastScroll = currentScroll;
});

// =========================
// DYNAMIC YEAR IN FOOTER
// =========================
document.getElementById(â€˜yearâ€™).textContent = new Date().getFullYear();

// =========================
// PRELOAD ANIMATIONS
// =========================
window.addEventListener(â€˜loadâ€™, () => {
document.body.style.opacity = â€˜1â€™;
});

// =========================
// KEYBOARD NAVIGATION IMPROVEMENTS
// =========================
document.addEventListener(â€˜keydownâ€™, (e) => {
// Escape key closes mobile nav
if (e.key === â€˜Escapeâ€™ && nav.classList.contains(â€˜openâ€™)) {
nav.classList.remove(â€˜openâ€™);
navToggle.classList.remove(â€˜openâ€™);
navToggle.setAttribute(â€˜aria-expandedâ€™, â€˜falseâ€™);
}

// Arrow keys for carousel navigation
if (document.activeElement.closest(â€™.skills-carousel-wrapperâ€™)) {
if (e.key === â€˜ArrowLeftâ€™) {
e.preventDefault();
prevBtn.click();
} else if (e.key === â€˜ArrowRightâ€™) {
e.preventDefault();
nextBtn.click();
}
}
});

// =========================
// LOADING STATE
// =========================
document.addEventListener(â€˜DOMContentLoadedâ€™, () => {
// Remove loading class if you add one
document.body.classList.remove(â€˜loadingâ€™);

// Initialize any other components
console.log(â€˜Portfolio loaded successfully! ðŸš€â€™);
});
